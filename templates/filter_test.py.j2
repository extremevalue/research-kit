{#
Filter Test Template for QuantConnect

This template generates algorithms that test an indicator as a filter
on a base strategy. The filter can be used as:
- Entry filter (only enter when filter is favorable)
- Exit filter (exit when filter becomes unfavorable)
- Both (entry and exit)

Variables:
    - component_id: Catalog entry ID
    - name: Human-readable name
    - start_date, end_date: Test period
    - initial_capital: Starting capital
    - data_sources: Data sources from registry
    - parameters: Strategy parameters
    - filter_indicator: Which indicator to use as filter
    - filter_column: Column name in the indicator data
    - filter_threshold: Threshold value for filter signal
    - filter_direction: 'above' or 'below' threshold
    - filter_role: 'entry', 'exit', or 'both'
    - base_strategy: The underlying strategy to filter
#}
# region imports
from AlgorithmImports import *
import json
from datetime import datetime, timedelta
# endregion


class {{ component_id | replace('-', '') }}FilterTest(QCAlgorithm):
    """
    {{ name }} - Filter Test

    Tests {{ filter_indicator }} as a {{ filter_role }} filter on {{ base_strategy }}.
    Filter: {{ filter_direction }} {{ filter_threshold }}

    Auto-generated for {{ component_id }}
    Test Period: {{ start_date }} to {{ end_date }}
    """

    def Initialize(self):
        # Basic settings
        self.SetStartDate({{ start_date.split('-')[0] }}, {{ start_date.split('-')[1] | int }}, {{ start_date.split('-')[2] | int }})
        self.SetEndDate({{ end_date.split('-')[0] }}, {{ end_date.split('-')[1] | int }}, {{ end_date.split('-')[2] | int }})
        self.SetCash({{ initial_capital | default(100000) }})

        # Component metadata
        self.component_id = "{{ component_id }}"
        self.test_type = "{{ test_type | default('is') }}_filter"

        # Add SPY
        self.spy = self.AddEquity("SPY", Resolution.Daily)
        self.SetBenchmark("SPY")
        self.SetBrokerageModel(BrokerageName.InteractiveBrokersBrokerage)

        # Filter parameters
        self.filter_indicator = "{{ filter_indicator }}"
        self.filter_column = "{{ filter_column }}"
        self.filter_threshold = {{ filter_threshold }}
        self.filter_direction = "{{ filter_direction }}"  # 'above' or 'below'
        self.filter_role = "{{ filter_role }}"  # 'entry', 'exit', or 'both'

        # Base strategy parameters
        self.base_strategy = "{{ base_strategy }}"
        self.parameters = {
{% for key, value in parameters.items() %}
            "{{ key }}": {{ value | tojson }},
{% endfor %}
        }

        # Base strategy indicators
{% if base_strategy == 'SMA_CROSSOVER' %}
        self.sma_fast = self.SMA("SPY", self.parameters.get("sma_fast", 50), Resolution.Daily)
        self.sma_slow = self.SMA("SPY", self.parameters.get("sma_slow", 200), Resolution.Daily)
{% elif base_strategy == 'RSI_MEAN_REVERSION' %}
        self.rsi = self.RSI("SPY", self.parameters.get("rsi_period", 14), Resolution.Daily)
{% elif base_strategy == 'MOMENTUM' %}
        self.momp = self.MOMP("SPY", self.parameters.get("momentum_period", 12), Resolution.Daily)
{% endif %}

        # Data loading
        self.external_data = {}
        self._load_external_data()

        # State tracking
        self.is_invested = False
        self.trade_count = 0
        self.last_filter_state = None
        self.entry_price = 0
        self.daily_returns = []

        # Schedule daily analysis
        self.Schedule.On(
            self.DateRules.EveryDay("SPY"),
            self.TimeRules.AfterMarketOpen("SPY", 30),
            self.DailyAnalysis
        )

        # Warm-up
        self.SetWarmUp(timedelta(days={{ warmup_days | default(252) }}))

    def _load_external_data(self):
        """Load external data from Object Store."""
{% for source in data_sources %}
{% if source.source == 'qc_object_store' %}
        # {{ source.id }}
        try:
            raw_data = self.ObjectStore.Read("{{ source.key }}")
            lines = raw_data.strip().split("\n")
            self.external_data["{{ source.id }}"] = {}

            for line in lines[1:]:  # Skip header
                parts = line.split(",")
                if len(parts) >= {{ source.min_columns | default(2) }}:
                    date_str = parts[{{ source.column_indices.date | default(0) }}].strip()
                    try:
                        date = datetime.strptime(date_str, "{{ source.date_format | default('%Y-%m-%d') }}")
{% for col_name, col_idx in source.column_indices.items() %}
{% if col_name != 'date' %}
                        {{ col_name }} = float(parts[{{ col_idx }}].strip()) if parts[{{ col_idx }}].strip() else None
{% endif %}
{% endfor %}
                        self.external_data["{{ source.id }}"][date] = {
{% for col_name, col_idx in source.column_indices.items() %}
{% if col_name != 'date' %}
                            "{{ col_name }}": {{ col_name }},
{% endif %}
{% endfor %}
                        }
                    except (ValueError, IndexError):
                        continue

            self.Debug(f"Loaded {{ source.id }}: {len(self.external_data['{{ source.id }}'])} records")
        except Exception as e:
            self.Error(f"Failed to load {{ source.id }}: {e}")
{% endif %}
{% endfor %}

    def get_indicator_value(self, data_id: str, column: str, days_back: int = 1) -> float | None:
        """Get indicator value with lag to avoid look-ahead bias."""
        if data_id not in self.external_data:
            return None

        target_date = self.Time.date() - timedelta(days=days_back)

        for i in range(5):
            check_date = datetime.combine(target_date - timedelta(days=i), datetime.min.time())
            if check_date in self.external_data[data_id]:
                data = self.external_data[data_id][check_date]
                return data.get(column)

        return None

    def get_filter_signal(self) -> bool:
        """
        Get the filter signal based on configuration.

        Returns:
            True if filter allows trading, False otherwise
        """
        value = self.get_indicator_value(
            self.filter_indicator,
            self.filter_column,
            days_back={{ filter_lag_days | default(1) }}
        )

        if value is None:
            return False  # No data = no trading

        if self.filter_direction == "above":
            return value > self.filter_threshold
        else:  # below
            return value < self.filter_threshold

    def get_base_strategy_signal(self) -> int:
        """
        Get signal from base strategy.

        Returns:
            1 = bullish/long, -1 = bearish/short, 0 = neutral
        """
{% if base_strategy == 'SMA_CROSSOVER' %}
        if not self.sma_fast.IsReady or not self.sma_slow.IsReady:
            return 0

        if self.sma_fast.Current.Value > self.sma_slow.Current.Value:
            return 1
        else:
            return -1
{% elif base_strategy == 'RSI_MEAN_REVERSION' %}
        if not self.rsi.IsReady:
            return 0

        rsi_val = self.rsi.Current.Value
        oversold = self.parameters.get("rsi_oversold", 30)
        overbought = self.parameters.get("rsi_overbought", 70)

        if rsi_val < oversold:
            return 1  # Oversold = buy signal
        elif rsi_val > overbought:
            return -1  # Overbought = sell signal
        else:
            return 0
{% elif base_strategy == 'MOMENTUM' %}
        if not self.momp.IsReady:
            return 0

        if self.momp.Current.Value > 0:
            return 1
        else:
            return -1
{% elif base_strategy == 'BUY_AND_HOLD' %}
        return 1  # Always bullish
{% else %}
        return 0
{% endif %}

    def DailyAnalysis(self):
        """Daily strategy analysis."""
        if self.IsWarmingUp:
            return

        # Track returns
        if hasattr(self, '_prev_value'):
            daily_ret = (self.Portfolio.TotalPortfolioValue - self._prev_value) / self._prev_value
            self.daily_returns.append(daily_ret)
        self._prev_value = self.Portfolio.TotalPortfolioValue

        # Get signals
        filter_allows = self.get_filter_signal()
        base_signal = self.get_base_strategy_signal()

        # Apply filter based on role
        should_be_invested = False

        if self.filter_role == "entry":
            # Filter only affects entries
            if self.is_invested:
                # Already invested - exit based on base strategy only
                should_be_invested = (base_signal >= 0)
            else:
                # Not invested - need filter AND base signal
                should_be_invested = filter_allows and (base_signal > 0)

        elif self.filter_role == "exit":
            # Filter only affects exits
            if base_signal > 0:
                should_be_invested = True
            elif base_signal < 0:
                should_be_invested = False
            else:
                # Neutral base signal - use filter for exit decision
                should_be_invested = filter_allows

        else:  # 'both'
            # Filter affects both entry and exit
            should_be_invested = filter_allows and (base_signal >= 0)

        # Execute trades
        if should_be_invested and not self.is_invested:
            self.SetHoldings("SPY", 1.0)
            self.is_invested = True
            self.entry_price = self.Securities["SPY"].Price
            self.trade_count += 1
            self.Debug(f"{self.Time.date()}: ENTER - Filter={filter_allows}, Base={base_signal}")

        elif not should_be_invested and self.is_invested:
            self.Liquidate("SPY")
            self.is_invested = False
            exit_price = self.Securities["SPY"].Price
            pnl = (exit_price - self.entry_price) / self.entry_price if self.entry_price > 0 else 0
            self.Debug(f"{self.Time.date()}: EXIT - PnL={pnl:.2%}")

    def OnData(self, data: Slice):
        """Process incoming data."""
        pass

    def OnEndOfAlgorithm(self):
        """Log final statistics."""
        self.Debug(f"=== {self.component_id} Filter Test Results ===")
        self.Debug(f"Filter: {self.filter_indicator} {self.filter_direction} {self.filter_threshold}")
        self.Debug(f"Base Strategy: {self.base_strategy}")
        self.Debug(f"Filter Role: {self.filter_role}")
        self.Debug(f"Total trades: {self.trade_count}")

        if self.daily_returns:
            import statistics
            avg_return = statistics.mean(self.daily_returns)
            std_return = statistics.stdev(self.daily_returns) if len(self.daily_returns) > 1 else 0
            sharpe = (avg_return * 252) / (std_return * (252 ** 0.5)) if std_return > 0 else 0
            self.Debug(f"Estimated Sharpe: {sharpe:.3f}")
