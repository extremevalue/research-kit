{#
Base Algorithm Template for QuantConnect

This Jinja2 template generates QC algorithms for validation testing.
All generated algorithms follow consistent patterns and load data
from the data registry.

Variables:
    - component_id: Catalog entry ID (e.g., IND-002)
    - name: Human-readable name
    - start_date: Backtest start date (YYYY-MM-DD)
    - end_date: Backtest end date (YYYY-MM-DD)
    - initial_capital: Starting capital (default 100000)
    - benchmark: Benchmark symbol (default SPY)
    - data_sources: List of data source configs from registry
    - parameters: Strategy-specific parameters
    - strategy_logic: Strategy logic block to inject
#}
# region imports
from AlgorithmImports import *
import json
from datetime import datetime, timedelta
# endregion


class {{ component_id | replace('-', '') }}Algorithm(QCAlgorithm):
    """
    {{ name }}

    Auto-generated validation algorithm for {{ component_id }}
    Generated: {{ generated_at | default('{now}') }}

    Test Period: {{ start_date }} to {{ end_date }}
    """

    def Initialize(self):
        # Basic settings
        self.SetStartDate({{ start_date.split('-')[0] }}, {{ start_date.split('-')[1] | int }}, {{ start_date.split('-')[2] | int }})
        self.SetEndDate({{ end_date.split('-')[0] }}, {{ end_date.split('-')[1] | int }}, {{ end_date.split('-')[2] | int }})
        self.SetCash({{ initial_capital | default(100000) }})

        # Component metadata
        self.component_id = "{{ component_id }}"
        self.test_type = "{{ test_type | default('is') }}"

        # Add benchmark
        self.benchmark = self.AddEquity("{{ benchmark | default('SPY') }}", Resolution.Daily)
        self.SetBenchmark("{{ benchmark | default('SPY') }}")

        # Universe - SPY for single-asset testing
        self.spy = self.AddEquity("SPY", Resolution.Daily)
        self.SetBrokerageModel(BrokerageName.InteractiveBrokersBrokerage)

        # Strategy parameters (locked before testing)
        self.parameters = {
{% for key, value in parameters.items() %}
            "{{ key }}": {{ value | tojson }},
{% endfor %}
        }

        # Data loading
        self.external_data = {}
        self._load_external_data()

        # State tracking
        self.is_invested = False
        self.last_signal = None
        self.trade_count = 0
        self.daily_returns = []

        # Schedule daily analysis
        self.Schedule.On(
            self.DateRules.EveryDay("SPY"),
            self.TimeRules.AfterMarketOpen("SPY", 30),
            self.DailyAnalysis
        )

        # Warm-up period
        self.SetWarmUp(timedelta(days={{ warmup_days | default(30) }}))

    def _load_external_data(self):
        """Load external data from Object Store."""
{% for source in data_sources %}
{% if source.source == 'qc_object_store' %}
        # {{ source.id }}: {{ source.name | default(source.id) }}
        try:
            raw_data = self.ObjectStore.Read("{{ source.key }}")
            lines = raw_data.strip().split("\n")
            self.external_data["{{ source.id }}"] = {}

            for line in lines[1:]:  # Skip header
                parts = line.split(",")
                if len(parts) >= {{ source.min_columns | default(2) }}:
                    date_str = parts[{{ source.column_indices.date | default(0) }}].strip()
                    try:
                        date = datetime.strptime(date_str, "{{ source.date_format | default('%Y-%m-%d') }}")
{% for col_name, col_idx in source.column_indices.items() %}
{% if col_name != 'date' %}
                        {{ col_name }} = float(parts[{{ col_idx }}].strip()) if parts[{{ col_idx }}].strip() else None
{% endif %}
{% endfor %}
                        self.external_data["{{ source.id }}"][date] = {
{% for col_name, col_idx in source.column_indices.items() %}
{% if col_name != 'date' %}
                            "{{ col_name }}": {{ col_name }},
{% endif %}
{% endfor %}
                        }
                    except (ValueError, IndexError) as e:
                        continue

            self.Debug(f"Loaded {{ source.id }}: {len(self.external_data['{{ source.id }}'])} records")
        except Exception as e:
            self.Error(f"Failed to load {{ source.id }}: {e}")
{% endif %}
{% endfor %}

    def get_indicator_value(self, data_id: str, column: str, days_back: int = 1) -> float | None:
        """
        Get indicator value with proper lag to avoid look-ahead bias.

        Args:
            data_id: Data source ID from registry
            column: Column name to retrieve
            days_back: Days of lag (1 = T-1, previous day)

        Returns:
            Indicator value or None if not available
        """
        if data_id not in self.external_data:
            return None

        target_date = self.Time.date() - timedelta(days=days_back)

        # Look for the value, going back up to 5 days to handle weekends/holidays
        for i in range(5):
            check_date = datetime.combine(target_date - timedelta(days=i), datetime.min.time())
            if check_date in self.external_data[data_id]:
                data = self.external_data[data_id][check_date]
                return data.get(column)

        return None

    def DailyAnalysis(self):
        """Daily strategy analysis - called after market open."""
        if self.IsWarmingUp:
            return

        # Track daily returns
        if self.Portfolio.TotalPortfolioValue > 0:
            if hasattr(self, '_prev_portfolio_value'):
                daily_return = (self.Portfolio.TotalPortfolioValue - self._prev_portfolio_value) / self._prev_portfolio_value
                self.daily_returns.append(daily_return)
            self._prev_portfolio_value = self.Portfolio.TotalPortfolioValue

{{ strategy_logic | indent(8) }}

    def OnData(self, data: Slice):
        """Process incoming data."""
        pass  # Strategy logic is in DailyAnalysis for consistency

    def OnEndOfAlgorithm(self):
        """Log final statistics."""
        self.Debug(f"=== {self.component_id} Final Results ===")
        self.Debug(f"Total trades: {self.trade_count}")

        if self.daily_returns:
            import statistics
            avg_return = statistics.mean(self.daily_returns)
            std_return = statistics.stdev(self.daily_returns) if len(self.daily_returns) > 1 else 0
            sharpe = (avg_return * 252) / (std_return * (252 ** 0.5)) if std_return > 0 else 0
            self.Debug(f"Sharpe estimate: {sharpe:.3f}")
